# SQL注入检测引擎优化总结

## 问题：

​		基于语义分析的SQL注入检测引擎检测速度较慢，单线程模式下只有160条/s。

## 成果：

​		优化后在单线程模式下达到5w条/s左右。

## 工具：

perf、pstack

（1）pstack适用场景：

程序崩溃后，通过pstack分析崩溃堆栈。

调试程序的性能瓶颈，查看热点代码。

还可以分析死锁问题。

```
pstack <pid> 查看进程实时调用堆栈
```

（2）perf用于识别性能瓶颈、进行性能调优、分析 CPU 使用情况、跟踪系统调用、分析内存访问等

```
perf list :查看perf支持的性能监控列表
perf stat: 统计程序运行时的性能事件
perf top:  实时显示cpu占用最高的函数和指令
perf record： 收集性能数据并保存到文件
perf report： 分析和查看收集的性能数据
```

## 实践：

（1）通过多次调用pstack <pid> 发现引擎在做词法分析运行中，持续调用init函数，重复构造存储sql关键字的字典树，导致程序巨慢，优化方案：关键字只在引擎启动时初始化，引擎停止时析构，当需要使用该字典树时，传入该字典树的指针。

（2）采用perf stat分析程序，发现context-switches次数特别多，上下文切换过多的原因有：线程调度；系统调用；等待IO等，首先怀疑的是系统调用过多导致，因为引擎是个计算密集型程序，IO较少，同时，程序的线程数设置合理，为CPU核数；于是采用perf record、perf report进一步分析，通过perf report以及生成的火焰图发现程序在系统调用中占用大量时间，主要都是申请内存、释放内存操作。

（3）程序中用的比较多的容器是vector、map，还用了string。优化首先锁定在string中，程序中采用string表示词法分析的token，但token其实本身对应着枚举类型，所以采用枚举类型直接表示token，因为枚举类型本身不涉及内存申请、释放，而string类型的构造、析构伴随着内存的申请和释放；第二，在做语义分析过程中，程序中采用了很多vector保存临时结果，但是这是多余的，完全可以在一个vector中完成所有操作；函数调用时，有些采用的是值传递，而不是引用传递，这也会导致临时变量的产生，进而导致内存的申请和释放；map的使用不合理。

## 总结：

（1）根据实际的使用场景选择合适的容器，比如动态扩容场景使用vector，固定大小使用array。

（2）编程时，尽量减少内存的申请和释放，**流量检测设备对于实时性要求较高，需要保证高可用、高可靠、高并发**，同时流量检测设备会长期不间断运行，频繁的内存操作会增加延迟，同时还会导致内存空间出现内部碎片和外部碎片，也会导致缓存失效，导致系统的不稳定，实际的解决方案：

​			1）：对于一些只读的变量，在引擎初始化时初始化一次，并在后续中通过传指针或者引用方式进行复用；

​			2）：如果可以，在一块内存完成所有操作，避免内存的不断申请和释放，变量的拷贝和析构；

​			3）：将vetor中的string类型改为枚举类型，减少内存的申请和释放，以及字符串的拷贝构造；

​			4）：使用对象池提前分配空间，可以减少内存的碎片化；

​			5）：在使用map时，如果后续还要使用key对应的value值，那么使用find，而不是count和[]的组合，因为find和count的底层调用是相同的，使用count和[]组合就会多了insert操作，因为[]底层是调用红黑树的insert函数。

​			6）：c++中尽量采用引用变量，从而减少的内存申请和释放，从而减少上下文切换。

​			7）：使用多线程编程时，应该控制线程数量，线程数量不是越多越好，因为线程数过多，容易导致上下文切换，上下文的切换开销是很大的。

​			8）：可以通过绑定cpu核心运行的方式优化程序，这样可以使得cpu能够更好地利用缓存，避免cpu迁移导致的缓存失效，同时将不同的线程绑定在不同的核心，也能够减少cpu的竞争，减少上下文切换。

（3）g++编译采用o2编译优化，遇到的问题，优化前没有段错误，优化后出现段错误，问题在于没有返回值，开启o2优化后，需要严格按照c++语法进行编程，避免ub行为。

![Alt text](https://github.com/wgdupup/notes/blob/main/assets/1.jpg)

其他：

（1）后续可以研究lto以及pgo优化。

（2）在numa架构系统中，避免缓存抖动/伪共享

```
getconf -a | grep CACHE
可以查看cpu内部L1、L2、L3缓存大小
```

```
ubuntu20.0.4下执行命令
LEVEL1_ICACHE_SIZE                 32768 //表示指令缓存大小
LEVEL1_ICACHE_ASSOC                8     //指令缓存的关联度，即每个缓存组中可以存放的缓存行数,8 表示 L1 指令缓存是 8 路组相联的，每个缓存组中有 8 个位置来存放缓存行。
LEVEL1_ICACHE_LINESIZE             64	//每个缓存行的大小，表示从内存中读取数据时，每次加载的数据量。
LEVEL1_DCACHE_SIZE                 49152// L1 数据缓存的总大小，表示缓存存储的数据量
LEVEL1_DCACHE_ASSOC                12	//L1 数据缓存的组相联度，表示每个缓存组中可以存放的缓存行数。
LEVEL1_DCACHE_LINESIZE             64	//L1 数据缓存中的缓存行大小。每个缓存行的大小为 64 字节，每次从缓存读取的数据量是 64 字节。
LEVEL2_CACHE_SIZE                  1310720
LEVEL2_CACHE_ASSOC                 10
LEVEL2_CACHE_LINESIZE              64
LEVEL3_CACHE_SIZE                  18874368
LEVEL3_CACHE_ASSOC                 12
LEVEL3_CACHE_LINESIZE              64
LEVEL4_CACHE_SIZE                  0
LEVEL4_CACHE_ASSOC                 0
LEVEL4_CACHE_LINESIZE              0
```

