# SQL注入检测引擎优化总结

## 背景：

​		基于语义分析的SQL注入检测引擎检测速度较慢，单线程模式下只有160条/s。

成果：

​		优化后在单线程模式下达到25w条/s左右。

## 工具：

perf、pstack

（1）pstack适用场景：

程序崩溃后，通过pstack分析崩溃堆栈。

调试程序的性能瓶颈，查看热点代码。**

还可以分析死锁问题。

## 总结：

（1）根据实际的使用场景选择合适的容器，比如动态扩容场景使用vector，固定大小使用array。

（2）编程时，尽量减少内存的申请和释放，**流量检测设备对于实时性要求较高，需要保证高可用、高可靠、高并发**，同时流量检测设备会长期不间断运行，频繁的内存操作会增加延迟，同时还会导致内存空间出现内部碎片和外部碎片，也会导致缓存失效，导致系统的不稳定，实际的解决方案：

​			1）：对于一些只读的变量，在引擎初始化时初始化一次，并在后续中通过传指针或者引用方式进行复用；

​			2）：如果可以，在一块内存完成所有操作，避免内存的不断申请和释放，变量的拷贝和析构；

​			3）：将vetor中的string类型改为枚举类型，减少内存的申请和释放，以及字符串的拷贝构造；

​			4）：使用对象池提前分配空间，可以减少内存的碎片化；

​			5）：在使用map时，如果后续还要使用key对应的value值，那么使用find，而不是count和[]的组合，因为find和count的底层调用是相同的，使用count和[]组合就会多了insert操作，因为[]底层是调用红黑树的insert函数。

​			6）：c++中尽量采用引用变量，从而减少的内存申请和释放，从而减少上下文切换。

​			7）：使用多线程编程时，应该控制线程数量，线程数量不是越多越好，因为线程数过多，容易导致上下文切换，上下文的切换开销是很大的。

​			8）：可以通过绑定cpu核心运行的方式优化程序，这样可以使得cpu能够更好地利用缓存，避免cpu迁移导致的缓存失效，同时将不同的线程绑定在不同的核心，也能够减少cpu的竞争，减少上下文切换。

（3）g++编译采用o2编译优化，遇到的问题，优化前没有段错误，优化后出现段错误，问题在于没有返回值，开启o2优化后，需要严格按照c++语法进行编程，避免ub行为。

![Alt text](https://github.com/wgdupup/notes/blob/main/assets/1.jpg)

其他：

（1）后续可以研究lto以及pgo优化。

（2）在numa架构系统中，避免缓存抖动/伪共享

```
getconf -a | grep CACHE
可以查看cpu内部L1、L2、L3缓存大小
```

```
ubuntu20.0.4下执行命令
LEVEL1_ICACHE_SIZE                 32768 //表示指令缓存大小
LEVEL1_ICACHE_ASSOC                8     //指令缓存的关联度，即每个缓存组中可以存放的缓存行数,8 表示 L1 指令缓存是 8 路组相联的，每个缓存组中有 8 个位置来存放缓存行。
LEVEL1_ICACHE_LINESIZE             64	//每个缓存行的大小，表示从内存中读取数据时，每次加载的数据量。
LEVEL1_DCACHE_SIZE                 49152// L1 数据缓存的总大小，表示缓存存储的数据量
LEVEL1_DCACHE_ASSOC                12	//L1 数据缓存的组相联度，表示每个缓存组中可以存放的缓存行数。
LEVEL1_DCACHE_LINESIZE             64	//L1 数据缓存中的缓存行大小。每个缓存行的大小为 64 字节，每次从缓存读取的数据量是 64 字节。
LEVEL2_CACHE_SIZE                  1310720
LEVEL2_CACHE_ASSOC                 10
LEVEL2_CACHE_LINESIZE              64
LEVEL3_CACHE_SIZE                  18874368
LEVEL3_CACHE_ASSOC                 12
LEVEL3_CACHE_LINESIZE              64
LEVEL4_CACHE_SIZE                  0
LEVEL4_CACHE_ASSOC                 0
LEVEL4_CACHE_LINESIZE              0
```

