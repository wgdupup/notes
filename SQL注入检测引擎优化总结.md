# SQL注入检测引擎优化总结

（1）根据实际的使用场景选择合适的容器，比如动态扩容场景使用vector，固定大小使用array。

（2）编程时，尽量减少内存的申请和释放，**流量检测设备对于实时性要求较高，需要保证高可用、高可靠、高并发**，同时流量检测设备会长期不间断运行，频繁的内存操作会增加延迟，同时还会导致内存空间出现内部碎片和外部碎片，也会导致缓存失效，导致系统的不稳定，实际的解决方案：

​			1）：对于一些只读的变量，在引擎初始化时初始化一次，并在后续中通过传指针或者引用方式进行复用；

​			2）：如果可以，在一块内存完成所有操作，避免内存的不断申请和释放，变量的拷贝和析构；

​			3）：将vetor中的string类型改为枚举类型，减少内存的申请和释放，以及字符串的拷贝构造；

​			4）：使用对象池提前分配空间，可以减少内存的碎片化；

​			5）：在使用map时，如果后续还要使用key对应的value值，那么使用find，而不是count和[]的组合，因为find和count的底层调用是相同的，使用count和[]组合就会多了insert操作，因为[]底层是调用红黑树的insert函数。

​			6）：c++中尽量采用引用变量，从而减少的内存申请和释放，从而减少上下文切换。

​			7）：使用多线程编程时，应该控制线程数量，线程数量不是越多越好，因为线程数过多，容易导致上下文切换，上下文的切换开销是很大的。

​			8）：可以通过绑定cpu核心运行的方式优化程序，这样可以使得cpu能够更好地利用缓存，避免cpu迁移导致的缓存失效，同时将不同的线程绑定在不同的核心，也能够减少cpu的竞争，减少上下文切换。

（3）g++编译采用o2编译优化，遇到的问题，优化前没有段错误，优化后出现段错误，问题在于没有返回值，开启o2优化后，需要严格按照c++语法进行编程，避免ub行为。

![Alt text](https://github.com/wgdupup/notes/blob/main/assets/1.jpg)

其他：

（1）后续可以研究lto以及pgo优化。

（2）在numa架构系统中，避免缓存抖动/伪共享。

